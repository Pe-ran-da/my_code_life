```

!! 属于历史命令机制　可以查看上一次的正确输出

\　　转义字符

""  部分引用　"STRING"的引用会使STRING里的特殊字符能够被解释

''　完全引用　'STRING'能引用STRING里的所有字符（包括特殊字符也会被原样引用）. 这是一个比使用双引号(“)更强的引用

** 求幂运算符　let "z=2**3"
		     echo $z #z = 8
? 可检查变量设置情况　haha="asd"
					echo ${haha?} # 输出asd
					echo ${hah?} # 输出　bash: hah: 参数为空或未设置

$ 行的结尾. 在正则表达式里，一个$字符表示匹配一行的结尾。
例如：　grep "^$" 表示空行　也就是首尾

$* 将所有参数视为一个字符串，所有的位置参数都被当成单个单元。
$@ 将所有参数视为不同串，和$*相同，但每个参数都是一个引起的字符串。那是说，参数都是没有被解析或扩展，是完整无缺地被传递的。这是说在参数列表中的每一个参数都被看作是一个单独的单元。

例子：
#!/bin/bash
echo $0
echo "第１个参数" $1
echo "第２个参数" $2
echo "第３个参数" $3
echo "第５个参数" $5
echo "参数的总个数" $#
echo "全部参数之参数视为一个字符串" "$*"
echo "全部参数之参数视为不同串" "$@"

$? 保存了退出码的值,退出码的值可以是一个命令，一个函数，或者是一个脚本的退出码值(通俗讲就是：代表上一个命令执行是否成功的标志)，正确运行的是0,不正确的在1~255.

$$ 代表命令,脚本本身进程所在的PID，（$$变量常被用于脚本中生成一个"唯一的"临时文件，这通常比调用mktemp还要简单）　
当前运行的脚本的PID就是$$。

注：mktemp建立的一个暂存文件，供shell script使用。
mktemp tmp.XXXXX　它会根据输入的大X数目来随机生成个名字

() 圆括号括起来的命令是新开一个子shell来执行的。圆括号内的变量不能被脚本的其他部分访问。
{}　匿名函数，代码块里的变量算是全局变量，不像一个用圆括号括起来的命令组，一个用花括号括起的代码块不会以一个子shell运行

{}\ 路径名　基本用于find命令，并且它不是shell内建的，(查看内建还是关键字可以在type -a 查询内容）

|　管道，将上次的输出穿个下次作为输入
注：管道以子进程来运行, 因此不能引起变量的改变。 
例子：  
	variable="initial_value"
    echo "new_value" | read variable
    echo "variable = $variable"     # variable = initial_value

~+ 相当于$PWD
~- 相当于$OLDPWD
=~ 正则表达式　在[[]]里面使用。
^ 正则表达式的行首，字符"^"用于匹配一个文本的开头。





```





